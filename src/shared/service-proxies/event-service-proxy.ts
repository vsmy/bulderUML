/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.0.3.0 (NJsonSchema v10.0.21.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import 'rxjs/add/operator/finally';
import {
  mergeMap as _observableMergeMap,
  catchError as _observableCatch
} from 'rxjs/operators';
import {
  Observable,
  throwError as _observableThrow,
  of as _observableOf
} from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import {
  HttpClient,
  HttpHeaders,
  HttpResponse,
  HttpResponseBase
} from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class DocumentsServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getObservers(
    id: number | null | undefined
  ): Observable<DocumentObserversDto> {
    let url_ = this.baseUrl + '/api/Documents/GetObservers?';
    if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetObservers(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetObservers(<any>response_);
            } catch (e) {
              return <Observable<DocumentObserversDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<DocumentObserversDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetObservers(
    response: HttpResponseBase
  ): Observable<DocumentObserversDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = DocumentObserversDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<DocumentObserversDto>(<any>null);
  }

  /**
   * @return Success
   */
  getAll(): Observable<DocumentDto[]> {
    let url_ = this.baseUrl + '/api/Documents/GetAll';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<DocumentDto[]>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<DocumentDto[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<DocumentDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(DocumentDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<DocumentDto[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(id: number | null | undefined): Observable<DocumentDto> {
    let url_ = this.baseUrl + '/api/Documents/GetById?';
    if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<DocumentDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<DocumentDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetById(
    response: HttpResponseBase
  ): Observable<DocumentDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = DocumentDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<DocumentDto>(<any>null);
  }

  /**
   * @param doc (optional)
   * @return Success
   */
  update(doc: DocumentDto | null | undefined): Observable<XResp> {
    let url_ = this.baseUrl + '/api/Documents/Update';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(doc);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json'
      })
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<XResp>>(<any>_observableThrow(e));
            }
          } else return <Observable<XResp>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<XResp> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = XResp.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<XResp>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | null | undefined): Observable<XResp> {
    let url_ = this.baseUrl + '/api/Documents/Delete?';
    if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json'
      })
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<XResp>>(<any>_observableThrow(e));
            }
          } else return <Observable<XResp>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<XResp> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = XResp.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<XResp>(<any>null);
  }

  /**
   * @param doc (optional)
   * @return Success
   */
  create(doc: DocumentDto | null | undefined): Observable<XRespOfInt32> {
    let url_ = this.baseUrl + '/api/Documents/Create';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(doc);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json'
      })
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<XRespOfInt32>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<XRespOfInt32>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreate(
    response: HttpResponseBase
  ): Observable<XRespOfInt32> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = XRespOfInt32.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<XRespOfInt32>(<any>null);
  }

  /**
   * @param observableId (optional)
   * @return Success
   */
  getTreeItems(observableId: number | null | undefined): Observable<TreeItem> {
    let url_ = this.baseUrl + '/api/Documents/GetTreeItems?';
    if (observableId !== undefined)
      url_ += 'observableId=' + encodeURIComponent('' + observableId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTreeItems(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTreeItems(<any>response_);
            } catch (e) {
              return <Observable<TreeItem>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<TreeItem>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetTreeItems(
    response: HttpResponseBase
  ): Observable<TreeItem> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = TreeItem.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<TreeItem>(<any>null);
  }

  /**
   * @return Success
   */
  getAllMimeTypes(): Observable<MimeTypeControlDto[]> {
    let url_ = this.baseUrl + '/api/Documents/GetAllMimeTypes';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllMimeTypes(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllMimeTypes(<any>response_);
            } catch (e) {
              return <Observable<MimeTypeControlDto[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<MimeTypeControlDto[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAllMimeTypes(
    response: HttpResponseBase
  ): Observable<MimeTypeControlDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(MimeTypeControlDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<MimeTypeControlDto[]>(<any>null);
  }
}

@Injectable()
export class LanguagesServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @return Success
   */
  getAll(): Observable<LanguageDto[]> {
    let url_ = this.baseUrl + '/api/Languages/GetAll';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<LanguageDto[]>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<LanguageDto[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<LanguageDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(LanguageDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<LanguageDto[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(id: number | null | undefined): Observable<Languages> {
    let url_ = this.baseUrl + '/api/Languages/GetById?';
    if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<Languages>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<Languages>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetById(response: HttpResponseBase): Observable<Languages> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = Languages.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<Languages>(<any>null);
  }

  /**
   * @param doc (optional)
   * @return Success
   */
  update(doc: LanguageDto | null | undefined): Observable<XResp> {
    let url_ = this.baseUrl + '/api/Languages/Update';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(doc);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json'
      })
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<XResp>>(<any>_observableThrow(e));
            }
          } else return <Observable<XResp>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<XResp> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = XResp.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<XResp>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | null | undefined): Observable<XResp> {
    let url_ = this.baseUrl + '/api/Languages/Delete?';
    if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json'
      })
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<XResp>>(<any>_observableThrow(e));
            }
          } else return <Observable<XResp>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<XResp> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = XResp.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<XResp>(<any>null);
  }

  /**
   * @param doc (optional)
   * @return Success
   */
  create(doc: LanguageDto | null | undefined): Observable<XRespOfInt32> {
    let url_ = this.baseUrl + '/api/Languages/Create';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(doc);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json'
      })
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<XRespOfInt32>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<XRespOfInt32>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreate(
    response: HttpResponseBase
  ): Observable<XRespOfInt32> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = XRespOfInt32.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<XRespOfInt32>(<any>null);
  }
}

@Injectable()
export class StructureElementsServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param languageId (optional)
   * @return Success
   */
  getAll(
    languageId: number | null | undefined
  ): Observable<StructureElementDto[]> {
    let url_ = this.baseUrl + '/api/StructureElements/GetAll?';
    if (languageId !== undefined)
      url_ += 'languageId=' + encodeURIComponent('' + languageId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<StructureElementDto[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<StructureElementDto[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<StructureElementDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(StructureElementDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<StructureElementDto[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @param languageId (optional)
   * @return Success
   */
  getById(
    id: number | null | undefined,
    languageId: number | null | undefined
  ): Observable<StructureElementDto> {
    let url_ = this.baseUrl + '/api/StructureElements/GetById?';
    if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    if (languageId !== undefined)
      url_ += 'languageId=' + encodeURIComponent('' + languageId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<StructureElementDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<StructureElementDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetById(
    response: HttpResponseBase
  ): Observable<StructureElementDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = StructureElementDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<StructureElementDto>(<any>null);
  }

  /**
   * @param languageId (optional)
   * @param requestDto (optional)
   * @return Success
   */
  update(
    languageId: number | null | undefined,
    requestDto: StructureElementDto | null | undefined
  ): Observable<XResp> {
    let url_ = this.baseUrl + '/api/StructureElements/Update?';
    if (languageId !== undefined)
      url_ += 'languageId=' + encodeURIComponent('' + languageId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(requestDto);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json'
      })
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<XResp>>(<any>_observableThrow(e));
            }
          } else return <Observable<XResp>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<XResp> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = XResp.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<XResp>(<any>null);
  }

  /**
   * @param languageId (optional)
   * @param requestDto (optional)
   * @return Success
   */
  create(
    languageId: number | null | undefined,
    requestDto: StructureElementDto | null | undefined
  ): Observable<XResp> {
    let url_ = this.baseUrl + '/api/StructureElements/Create?';
    if (languageId !== undefined)
      url_ += 'languageId=' + encodeURIComponent('' + languageId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(requestDto);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json'
      })
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<XResp>>(<any>_observableThrow(e));
            }
          } else return <Observable<XResp>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<XResp> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = XResp.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<XResp>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | null | undefined): Observable<XResp> {
    let url_ = this.baseUrl + '/api/StructureElements/Delete?';
    if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json'
      })
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<XResp>>(<any>_observableThrow(e));
            }
          } else return <Observable<XResp>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<XResp> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = XResp.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<XResp>(<any>null);
  }

  /**
   * @return Success
   */
  getAllControlTypes(): Observable<ContentTypeControlDto[]> {
    let url_ = this.baseUrl + '/api/StructureElements/GetAllControlTypes';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllControlTypes(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllControlTypes(<any>response_);
            } catch (e) {
              return <Observable<ContentTypeControlDto[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<ContentTypeControlDto[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAllControlTypes(
    response: HttpResponseBase
  ): Observable<ContentTypeControlDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(ContentTypeControlDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<ContentTypeControlDto[]>(<any>null);
  }
}

@Injectable()
export class StructuresServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @return Success
   */
  getAll(): Observable<StructureShortDto[]> {
    let url_ = this.baseUrl + '/api/Structures/GetAll';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<StructureShortDto[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<StructureShortDto[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<StructureShortDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(StructureShortDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<StructureShortDto[]>(<any>null);
  }

  /**
   * @return Success
   */
  getDefaults(): Observable<StructureShortDto[]> {
    let url_ = this.baseUrl + '/api/Structures/GetDefaults';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDefaults(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDefaults(<any>response_);
            } catch (e) {
              return <Observable<StructureShortDto[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<StructureShortDto[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetDefaults(
    response: HttpResponseBase
  ): Observable<StructureShortDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(StructureShortDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<StructureShortDto[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | null | undefined): Observable<XResp> {
    let url_ = this.baseUrl + '/api/Structures/Delete?';
    if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json'
      })
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<XResp>>(<any>_observableThrow(e));
            }
          } else return <Observable<XResp>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<XResp> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = XResp.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<XResp>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(id: number | null | undefined): Observable<StructureDto> {
    let url_ = this.baseUrl + '/api/Structures/GetById?';
    if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<StructureDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<StructureDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetById(
    response: HttpResponseBase
  ): Observable<StructureDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = StructureDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<StructureDto>(<any>null);
  }

  /**
   * @param dto (optional)
   * @return Success
   */
  update(dto: StructureDto | null | undefined): Observable<XResp> {
    let url_ = this.baseUrl + '/api/Structures/Update';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(dto);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json'
      })
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<XResp>>(<any>_observableThrow(e));
            }
          } else return <Observable<XResp>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<XResp> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = XResp.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<XResp>(<any>null);
  }

  /**
   * @param dto (optional)
   * @return Success
   */
  create(dto: StructureDto | null | undefined): Observable<XResp> {
    let url_ = this.baseUrl + '/api/Structures/Create';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(dto);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json'
      })
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<XResp>>(<any>_observableThrow(e));
            }
          } else return <Observable<XResp>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<XResp> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = XResp.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<XResp>(<any>null);
  }

  /**
   * @param documentId (optional)
   * @param structureId (optional)
   * @return Success
   */
  assign(
    documentId: number | null | undefined,
    structureId: number | null | undefined
  ): Observable<XResp> {
    let url_ = this.baseUrl + '/api/Structures/Assign?';
    if (documentId !== undefined)
      url_ += 'documentId=' + encodeURIComponent('' + documentId) + '&';
    if (structureId !== undefined)
      url_ += 'structureId=' + encodeURIComponent('' + structureId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json'
      })
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAssign(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAssign(<any>response_);
            } catch (e) {
              return <Observable<XResp>>(<any>_observableThrow(e));
            }
          } else return <Observable<XResp>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAssign(response: HttpResponseBase): Observable<XResp> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = XResp.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<XResp>(<any>null);
  }
}

export class DocumentObserversDto implements IDocumentObserversDto {
  id: number | undefined;
  name: string | undefined;
  observers: ObserversDto[] | undefined;

  constructor(data?: IDocumentObserversDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id'];
      this.name = data['name'];
      if (Array.isArray(data['observers'])) {
        this.observers = [] as any;
        for (let item of data['observers'])
          this.observers.push(ObserversDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): DocumentObserversDto {
    data = typeof data === 'object' ? data : {};
    let result = new DocumentObserversDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    if (Array.isArray(this.observers)) {
      data['observers'] = [];
      for (let item of this.observers) data['observers'].push(item.toJSON());
    }
    return data;
  }

  clone(): DocumentObserversDto {
    const json = this.toJSON();
    let result = new DocumentObserversDto();
    result.init(json);
    return result;
  }
}

export interface IDocumentObserversDto {
  id: number | undefined;
  name: string | undefined;
  observers: ObserversDto[] | undefined;
}

export class ObserversDto implements IObserversDto {
  id: number | undefined;
  observationDate: moment.Moment | undefined;
  documentVersion: number | undefined;
  structure: StructureShortDto | undefined;

  constructor(data?: IObserversDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id'];
      this.observationDate = data['observationDate']
        ? moment(data['observationDate'].toString())
        : <any>undefined;
      this.documentVersion = data['documentVersion'];
      this.structure = data['structure']
        ? StructureShortDto.fromJS(data['structure'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): ObserversDto {
    data = typeof data === 'object' ? data : {};
    let result = new ObserversDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['observationDate'] = this.observationDate
      ? this.observationDate.toISOString()
      : <any>undefined;
    data['documentVersion'] = this.documentVersion;
    data['structure'] = this.structure
      ? this.structure.toJSON()
      : <any>undefined;
    return data;
  }

  clone(): ObserversDto {
    const json = this.toJSON();
    let result = new ObserversDto();
    result.init(json);
    return result;
  }
}

export interface IObserversDto {
  id: number | undefined;
  observationDate: moment.Moment | undefined;
  documentVersion: number | undefined;
  structure: StructureShortDto | undefined;
}

export class StructureShortDto implements IStructureShortDto {
  id: number | undefined;
  name: string | undefined;
  languageId: number | undefined;

  constructor(data?: IStructureShortDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id'];
      this.name = data['name'];
      this.languageId = data['languageId'];
    }
  }

  static fromJS(data: any): StructureShortDto {
    data = typeof data === 'object' ? data : {};
    let result = new StructureShortDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['languageId'] = this.languageId;
    return data;
  }

  clone(): StructureShortDto {
    const json = this.toJSON();
    let result = new StructureShortDto();
    result.init(json);
    return result;
  }
}

export interface IStructureShortDto {
  id: number | undefined;
  name: string | undefined;
  languageId: number | undefined;
}

export class DocumentDto implements IDocumentDto {
  id: number | undefined;
  name: string | undefined;
  shortName: string | undefined;
  abbreviation: string | undefined;
  sourceUrl: string | undefined;
  languageId: number | undefined;
  language: string | undefined;
  mimeTypeId: number | undefined;
  mimeType: string | undefined;
  observationStartDate: moment.Moment | undefined;
  observationPeriod: string | undefined;
  isDeleted: boolean | undefined;
  observationStatus: string | undefined;
  isHaveObservables: boolean | undefined;

  constructor(data?: IDocumentDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id'];
      this.name = data['name'];
      this.shortName = data['shortName'];
      this.abbreviation = data['abbreviation'];
      this.sourceUrl = data['sourceUrl'];
      this.languageId = data['languageId'];
      this.language = data['language'];
      this.mimeTypeId = data['mimeTypeId'];
      this.mimeType = data['mimeType'];
      this.observationStartDate = data['observationStartDate']
        ? moment(data['observationStartDate'].toString())
        : <any>undefined;
      this.observationPeriod = data['observationPeriod'];
      this.isDeleted = data['isDeleted'];
      this.observationStatus = data['observationStatus'];
      this.isHaveObservables = data['isHaveObservables'];
    }
  }

  static fromJS(data: any): DocumentDto {
    data = typeof data === 'object' ? data : {};
    let result = new DocumentDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['shortName'] = this.shortName;
    data['abbreviation'] = this.abbreviation;
    data['sourceUrl'] = this.sourceUrl;
    data['languageId'] = this.languageId;
    data['language'] = this.language;
    data['mimeTypeId'] = this.mimeTypeId;
    data['mimeType'] = this.mimeType;
    data['observationStartDate'] = this.observationStartDate
      ? this.observationStartDate.toISOString()
      : <any>undefined;
    data['observationPeriod'] = this.observationPeriod;
    data['isDeleted'] = this.isDeleted;
    data['observationStatus'] = this.observationStatus;
    data['isHaveObservables'] = this.isHaveObservables;
    return data;
  }

  clone(): DocumentDto {
    const json = this.toJSON();
    let result = new DocumentDto();
    result.init(json);
    return result;
  }
}

export interface IDocumentDto {
  id: number | undefined;
  name: string | undefined;
  shortName: string | undefined;
  abbreviation: string | undefined;
  sourceUrl: string | undefined;
  languageId: number | undefined;
  language: string | undefined;
  mimeTypeId: number | undefined;
  mimeType: string | undefined;
  observationStartDate: moment.Moment | undefined;
  observationPeriod: string | undefined;
  isDeleted: boolean | undefined;
  observationStatus: string | undefined;
  isHaveObservables: boolean | undefined;
}

export class XResp implements IXResp {
  message: IRespMsg | undefined;
  shortMessage: string | undefined;
  success: boolean | undefined;

  constructor(data?: IXResp) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.message = data['message']
        ? IRespMsg.fromJS(data['message'])
        : <any>undefined;
      this.shortMessage = data['shortMessage'];
      this.success = data['success'];
    }
  }

  static fromJS(data: any): XResp {
    data = typeof data === 'object' ? data : {};
    let result = new XResp();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['message'] = this.message ? this.message.toJSON() : <any>undefined;
    data['shortMessage'] = this.shortMessage;
    data['success'] = this.success;
    return data;
  }

  clone(): XResp {
    const json = this.toJSON();
    let result = new XResp();
    result.init(json);
    return result;
  }
}

export interface IXResp {
  message: IRespMsg | undefined;
  shortMessage: string | undefined;
  success: boolean | undefined;
}

export class IRespMsg implements IIRespMsg {
  constructor(data?: IIRespMsg) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {}

  static fromJS(data: any): IRespMsg {
    data = typeof data === 'object' ? data : {};
    let result = new IRespMsg();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    return data;
  }

  clone(): IRespMsg {
    const json = this.toJSON();
    let result = new IRespMsg();
    result.init(json);
    return result;
  }
}

export interface IIRespMsg {}

export class XRespOfInt32 implements IXRespOfInt32 {
  readonly model: number | undefined;
  message: IRespMsg | undefined;
  shortMessage: string | undefined;
  success: boolean | undefined;

  constructor(data?: IXRespOfInt32) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      (<any>this).model = data['model'];
      this.message = data['message']
        ? IRespMsg.fromJS(data['message'])
        : <any>undefined;
      this.shortMessage = data['shortMessage'];
      this.success = data['success'];
    }
  }

  static fromJS(data: any): XRespOfInt32 {
    data = typeof data === 'object' ? data : {};
    let result = new XRespOfInt32();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['model'] = this.model;
    data['message'] = this.message ? this.message.toJSON() : <any>undefined;
    data['shortMessage'] = this.shortMessage;
    data['success'] = this.success;
    return data;
  }

  clone(): XRespOfInt32 {
    const json = this.toJSON();
    let result = new XRespOfInt32();
    result.init(json);
    return result;
  }
}

export interface IXRespOfInt32 {
  model: number | undefined;
  message: IRespMsg | undefined;
  shortMessage: string | undefined;
  success: boolean | undefined;
}

export class TreeItem implements ITreeItem {
  childrenItems: TreeItem[] | undefined;
  id: number | undefined;
  status: string | undefined;
  partTextNew: string | undefined;
  partTextPrevious: string | undefined;

  constructor(data?: ITreeItem) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      if (Array.isArray(data['childrenItems'])) {
        this.childrenItems = [] as any;
        for (let item of data['childrenItems'])
          this.childrenItems.push(TreeItem.fromJS(item));
      }
      this.id = data['id'];
      this.status = data['status'];
      this.partTextNew = data['partTextNew'];
      this.partTextPrevious = data['partTextPrevious'];
    }
  }

  static fromJS(data: any): TreeItem {
    data = typeof data === 'object' ? data : {};
    let result = new TreeItem();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.childrenItems)) {
      data['childrenItems'] = [];
      for (let item of this.childrenItems)
        data['childrenItems'].push(item.toJSON());
    }
    data['id'] = this.id;
    data['status'] = this.status;
    data['partTextNew'] = this.partTextNew;
    data['partTextPrevious'] = this.partTextPrevious;
    return data;
  }

  clone(): TreeItem {
    const json = this.toJSON();
    let result = new TreeItem();
    result.init(json);
    return result;
  }
}

export interface ITreeItem {
  childrenItems: TreeItem[] | undefined;
  id: number | undefined;
  status: string | undefined;
  partTextNew: string | undefined;
  partTextPrevious: string | undefined;
}

export class MimeTypeControlDto implements IMimeTypeControlDto {
  id: number | undefined;
  name: string | undefined;

  constructor(data?: IMimeTypeControlDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id'];
      this.name = data['name'];
    }
  }

  static fromJS(data: any): MimeTypeControlDto {
    data = typeof data === 'object' ? data : {};
    let result = new MimeTypeControlDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    return data;
  }

  clone(): MimeTypeControlDto {
    const json = this.toJSON();
    let result = new MimeTypeControlDto();
    result.init(json);
    return result;
  }
}

export interface IMimeTypeControlDto {
  id: number | undefined;
  name: string | undefined;
}

export class LanguageDto implements ILanguageDto {
  id: number | undefined;
  name: string | undefined;
  code: string | undefined;

  constructor(data?: ILanguageDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id'];
      this.name = data['name'];
      this.code = data['code'];
    }
  }

  static fromJS(data: any): LanguageDto {
    data = typeof data === 'object' ? data : {};
    let result = new LanguageDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['code'] = this.code;
    return data;
  }

  clone(): LanguageDto {
    const json = this.toJSON();
    let result = new LanguageDto();
    result.init(json);
    return result;
  }
}

export interface ILanguageDto {
  id: number | undefined;
  name: string | undefined;
  code: string | undefined;
}

export class Languages implements ILanguages {
  id: number | undefined;
  name: string | undefined;
  code: string | undefined;
  documentStructures: DocumentStructures[] | undefined;
  documents: Documents[] | undefined;
  regExPatterns: RegExPatterns[] | undefined;

  constructor(data?: ILanguages) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id'];
      this.name = data['name'];
      this.code = data['code'];
      if (Array.isArray(data['documentStructures'])) {
        this.documentStructures = [] as any;
        for (let item of data['documentStructures'])
          this.documentStructures.push(DocumentStructures.fromJS(item));
      }
      if (Array.isArray(data['documents'])) {
        this.documents = [] as any;
        for (let item of data['documents'])
          this.documents.push(Documents.fromJS(item));
      }
      if (Array.isArray(data['regExPatterns'])) {
        this.regExPatterns = [] as any;
        for (let item of data['regExPatterns'])
          this.regExPatterns.push(RegExPatterns.fromJS(item));
      }
    }
  }

  static fromJS(data: any): Languages {
    data = typeof data === 'object' ? data : {};
    let result = new Languages();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['code'] = this.code;
    if (Array.isArray(this.documentStructures)) {
      data['documentStructures'] = [];
      for (let item of this.documentStructures)
        data['documentStructures'].push(item.toJSON());
    }
    if (Array.isArray(this.documents)) {
      data['documents'] = [];
      for (let item of this.documents) data['documents'].push(item.toJSON());
    }
    if (Array.isArray(this.regExPatterns)) {
      data['regExPatterns'] = [];
      for (let item of this.regExPatterns)
        data['regExPatterns'].push(item.toJSON());
    }
    return data;
  }

  clone(): Languages {
    const json = this.toJSON();
    let result = new Languages();
    result.init(json);
    return result;
  }
}

export interface ILanguages {
  id: number | undefined;
  name: string | undefined;
  code: string | undefined;
  documentStructures: DocumentStructures[] | undefined;
  documents: Documents[] | undefined;
  regExPatterns: RegExPatterns[] | undefined;
}

export class DocumentStructures implements IDocumentStructures {
  id: number | undefined;
  name: string | undefined;
  documentId: number | undefined;
  languageId: number | undefined;
  isDefault: boolean | undefined;
  document: Documents | undefined;
  language: Languages | undefined;
  structureNodes: StructureNodes[] | undefined;

  constructor(data?: IDocumentStructures) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id'];
      this.name = data['name'];
      this.documentId = data['documentId'];
      this.languageId = data['languageId'];
      this.isDefault = data['isDefault'];
      this.document = data['document']
        ? Documents.fromJS(data['document'])
        : <any>undefined;
      this.language = data['language']
        ? Languages.fromJS(data['language'])
        : <any>undefined;
      if (Array.isArray(data['structureNodes'])) {
        this.structureNodes = [] as any;
        for (let item of data['structureNodes'])
          this.structureNodes.push(StructureNodes.fromJS(item));
      }
    }
  }

  static fromJS(data: any): DocumentStructures {
    data = typeof data === 'object' ? data : {};
    let result = new DocumentStructures();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['documentId'] = this.documentId;
    data['languageId'] = this.languageId;
    data['isDefault'] = this.isDefault;
    data['document'] = this.document ? this.document.toJSON() : <any>undefined;
    data['language'] = this.language ? this.language.toJSON() : <any>undefined;
    if (Array.isArray(this.structureNodes)) {
      data['structureNodes'] = [];
      for (let item of this.structureNodes)
        data['structureNodes'].push(item.toJSON());
    }
    return data;
  }

  clone(): DocumentStructures {
    const json = this.toJSON();
    let result = new DocumentStructures();
    result.init(json);
    return result;
  }
}

export interface IDocumentStructures {
  id: number | undefined;
  name: string | undefined;
  documentId: number | undefined;
  languageId: number | undefined;
  isDefault: boolean | undefined;
  document: Documents | undefined;
  language: Languages | undefined;
  structureNodes: StructureNodes[] | undefined;
}

export class Documents implements IDocuments {
  id: number | undefined;
  name: string | undefined;
  shortName: string | undefined;
  abbreviation: string | undefined;
  sourceUrl: string | undefined;
  languageId: number | undefined;
  mimeTypeId: number | undefined;
  observationStartDate: moment.Moment | undefined;
  observationPeriod: string | undefined;
  isDeleted: boolean | undefined;
  createdAt: moment.Moment | undefined;
  updatedAt: moment.Moment | undefined;
  observationStatus: string | undefined;
  language: Languages | undefined;
  mimeType: MimeTypes | undefined;
  documentObservers: DocumentObservers[] | undefined;
  documentStructures: DocumentStructures[] | undefined;

  constructor(data?: IDocuments) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id'];
      this.name = data['name'];
      this.shortName = data['shortName'];
      this.abbreviation = data['abbreviation'];
      this.sourceUrl = data['sourceUrl'];
      this.languageId = data['languageId'];
      this.mimeTypeId = data['mimeTypeId'];
      this.observationStartDate = data['observationStartDate']
        ? moment(data['observationStartDate'].toString())
        : <any>undefined;
      this.observationPeriod = data['observationPeriod'];
      this.isDeleted = data['isDeleted'];
      this.createdAt = data['createdAt']
        ? moment(data['createdAt'].toString())
        : <any>undefined;
      this.updatedAt = data['updatedAt']
        ? moment(data['updatedAt'].toString())
        : <any>undefined;
      this.observationStatus = data['observationStatus'];
      this.language = data['language']
        ? Languages.fromJS(data['language'])
        : <any>undefined;
      this.mimeType = data['mimeType']
        ? MimeTypes.fromJS(data['mimeType'])
        : <any>undefined;
      if (Array.isArray(data['documentObservers'])) {
        this.documentObservers = [] as any;
        for (let item of data['documentObservers'])
          this.documentObservers.push(DocumentObservers.fromJS(item));
      }
      if (Array.isArray(data['documentStructures'])) {
        this.documentStructures = [] as any;
        for (let item of data['documentStructures'])
          this.documentStructures.push(DocumentStructures.fromJS(item));
      }
    }
  }

  static fromJS(data: any): Documents {
    data = typeof data === 'object' ? data : {};
    let result = new Documents();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['shortName'] = this.shortName;
    data['abbreviation'] = this.abbreviation;
    data['sourceUrl'] = this.sourceUrl;
    data['languageId'] = this.languageId;
    data['mimeTypeId'] = this.mimeTypeId;
    data['observationStartDate'] = this.observationStartDate
      ? this.observationStartDate.toISOString()
      : <any>undefined;
    data['observationPeriod'] = this.observationPeriod;
    data['isDeleted'] = this.isDeleted;
    data['createdAt'] = this.createdAt
      ? this.createdAt.toISOString()
      : <any>undefined;
    data['updatedAt'] = this.updatedAt
      ? this.updatedAt.toISOString()
      : <any>undefined;
    data['observationStatus'] = this.observationStatus;
    data['language'] = this.language ? this.language.toJSON() : <any>undefined;
    data['mimeType'] = this.mimeType ? this.mimeType.toJSON() : <any>undefined;
    if (Array.isArray(this.documentObservers)) {
      data['documentObservers'] = [];
      for (let item of this.documentObservers)
        data['documentObservers'].push(item.toJSON());
    }
    if (Array.isArray(this.documentStructures)) {
      data['documentStructures'] = [];
      for (let item of this.documentStructures)
        data['documentStructures'].push(item.toJSON());
    }
    return data;
  }

  clone(): Documents {
    const json = this.toJSON();
    let result = new Documents();
    result.init(json);
    return result;
  }
}

export interface IDocuments {
  id: number | undefined;
  name: string | undefined;
  shortName: string | undefined;
  abbreviation: string | undefined;
  sourceUrl: string | undefined;
  languageId: number | undefined;
  mimeTypeId: number | undefined;
  observationStartDate: moment.Moment | undefined;
  observationPeriod: string | undefined;
  isDeleted: boolean | undefined;
  createdAt: moment.Moment | undefined;
  updatedAt: moment.Moment | undefined;
  observationStatus: string | undefined;
  language: Languages | undefined;
  mimeType: MimeTypes | undefined;
  documentObservers: DocumentObservers[] | undefined;
  documentStructures: DocumentStructures[] | undefined;
}

export class RegExPatterns implements IRegExPatterns {
  id: number | undefined;
  languageId: number | undefined;
  structureNodeId: number | undefined;
  structureElementId: number | undefined;
  regEx: string | undefined;
  language: Languages | undefined;
  structureElement: StructureElements | undefined;
  structureNode: StructureNodes | undefined;

  constructor(data?: IRegExPatterns) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id'];
      this.languageId = data['languageId'];
      this.structureNodeId = data['structureNodeId'];
      this.structureElementId = data['structureElementId'];
      this.regEx = data['regEx'];
      this.language = data['language']
        ? Languages.fromJS(data['language'])
        : <any>undefined;
      this.structureElement = data['structureElement']
        ? StructureElements.fromJS(data['structureElement'])
        : <any>undefined;
      this.structureNode = data['structureNode']
        ? StructureNodes.fromJS(data['structureNode'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): RegExPatterns {
    data = typeof data === 'object' ? data : {};
    let result = new RegExPatterns();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['languageId'] = this.languageId;
    data['structureNodeId'] = this.structureNodeId;
    data['structureElementId'] = this.structureElementId;
    data['regEx'] = this.regEx;
    data['language'] = this.language ? this.language.toJSON() : <any>undefined;
    data['structureElement'] = this.structureElement
      ? this.structureElement.toJSON()
      : <any>undefined;
    data['structureNode'] = this.structureNode
      ? this.structureNode.toJSON()
      : <any>undefined;
    return data;
  }

  clone(): RegExPatterns {
    const json = this.toJSON();
    let result = new RegExPatterns();
    result.init(json);
    return result;
  }
}

export interface IRegExPatterns {
  id: number | undefined;
  languageId: number | undefined;
  structureNodeId: number | undefined;
  structureElementId: number | undefined;
  regEx: string | undefined;
  language: Languages | undefined;
  structureElement: StructureElements | undefined;
  structureNode: StructureNodes | undefined;
}

export class StructureNodes implements IStructureNodes {
  id: number | undefined;
  structureElementId: number | undefined;
  structureId: number | undefined;
  offsetX: number | undefined;
  offsetY: number | undefined;
  structure: DocumentStructures | undefined;
  structureElement: StructureElements | undefined;
  documentParts: DocumentParts[] | undefined;
  regExPatterns: RegExPatterns[] | undefined;
  structureConnectionsSourceStructureNode: StructureConnections[] | undefined;
  structureConnectionsTargetStructureNode: StructureConnections[] | undefined;

  constructor(data?: IStructureNodes) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id'];
      this.structureElementId = data['structureElementId'];
      this.structureId = data['structureId'];
      this.offsetX = data['offsetX'];
      this.offsetY = data['offsetY'];
      this.structure = data['structure']
        ? DocumentStructures.fromJS(data['structure'])
        : <any>undefined;
      this.structureElement = data['structureElement']
        ? StructureElements.fromJS(data['structureElement'])
        : <any>undefined;
      if (Array.isArray(data['documentParts'])) {
        this.documentParts = [] as any;
        for (let item of data['documentParts'])
          this.documentParts.push(DocumentParts.fromJS(item));
      }
      if (Array.isArray(data['regExPatterns'])) {
        this.regExPatterns = [] as any;
        for (let item of data['regExPatterns'])
          this.regExPatterns.push(RegExPatterns.fromJS(item));
      }
      if (Array.isArray(data['structureConnectionsSourceStructureNode'])) {
        this.structureConnectionsSourceStructureNode = [] as any;
        for (let item of data['structureConnectionsSourceStructureNode'])
          this.structureConnectionsSourceStructureNode.push(
            StructureConnections.fromJS(item)
          );
      }
      if (Array.isArray(data['structureConnectionsTargetStructureNode'])) {
        this.structureConnectionsTargetStructureNode = [] as any;
        for (let item of data['structureConnectionsTargetStructureNode'])
          this.structureConnectionsTargetStructureNode.push(
            StructureConnections.fromJS(item)
          );
      }
    }
  }

  static fromJS(data: any): StructureNodes {
    data = typeof data === 'object' ? data : {};
    let result = new StructureNodes();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['structureElementId'] = this.structureElementId;
    data['structureId'] = this.structureId;
    data['offsetX'] = this.offsetX;
    data['offsetY'] = this.offsetY;
    data['structure'] = this.structure
      ? this.structure.toJSON()
      : <any>undefined;
    data['structureElement'] = this.structureElement
      ? this.structureElement.toJSON()
      : <any>undefined;
    if (Array.isArray(this.documentParts)) {
      data['documentParts'] = [];
      for (let item of this.documentParts)
        data['documentParts'].push(item.toJSON());
    }
    if (Array.isArray(this.regExPatterns)) {
      data['regExPatterns'] = [];
      for (let item of this.regExPatterns)
        data['regExPatterns'].push(item.toJSON());
    }
    if (Array.isArray(this.structureConnectionsSourceStructureNode)) {
      data['structureConnectionsSourceStructureNode'] = [];
      for (let item of this.structureConnectionsSourceStructureNode)
        data['structureConnectionsSourceStructureNode'].push(item.toJSON());
    }
    if (Array.isArray(this.structureConnectionsTargetStructureNode)) {
      data['structureConnectionsTargetStructureNode'] = [];
      for (let item of this.structureConnectionsTargetStructureNode)
        data['structureConnectionsTargetStructureNode'].push(item.toJSON());
    }
    return data;
  }

  clone(): StructureNodes {
    const json = this.toJSON();
    let result = new StructureNodes();
    result.init(json);
    return result;
  }
}

export interface IStructureNodes {
  id: number | undefined;
  structureElementId: number | undefined;
  structureId: number | undefined;
  offsetX: number | undefined;
  offsetY: number | undefined;
  structure: DocumentStructures | undefined;
  structureElement: StructureElements | undefined;
  documentParts: DocumentParts[] | undefined;
  regExPatterns: RegExPatterns[] | undefined;
  structureConnectionsSourceStructureNode: StructureConnections[] | undefined;
  structureConnectionsTargetStructureNode: StructureConnections[] | undefined;
}

export class MimeTypes implements IMimeTypes {
  id: number | undefined;
  name: string | undefined;
  documents: Documents[] | undefined;

  constructor(data?: IMimeTypes) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id'];
      this.name = data['name'];
      if (Array.isArray(data['documents'])) {
        this.documents = [] as any;
        for (let item of data['documents'])
          this.documents.push(Documents.fromJS(item));
      }
    }
  }

  static fromJS(data: any): MimeTypes {
    data = typeof data === 'object' ? data : {};
    let result = new MimeTypes();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    if (Array.isArray(this.documents)) {
      data['documents'] = [];
      for (let item of this.documents) data['documents'].push(item.toJSON());
    }
    return data;
  }

  clone(): MimeTypes {
    const json = this.toJSON();
    let result = new MimeTypes();
    result.init(json);
    return result;
  }
}

export interface IMimeTypes {
  id: number | undefined;
  name: string | undefined;
  documents: Documents[] | undefined;
}

export class DocumentObservers implements IDocumentObservers {
  id: number | undefined;
  observationDate: moment.Moment | undefined;
  documentId: number | undefined;
  documentVersion: number | undefined;
  document: Documents | undefined;
  documentParts: DocumentParts[] | undefined;

  constructor(data?: IDocumentObservers) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id'];
      this.observationDate = data['observationDate']
        ? moment(data['observationDate'].toString())
        : <any>undefined;
      this.documentId = data['documentId'];
      this.documentVersion = data['documentVersion'];
      this.document = data['document']
        ? Documents.fromJS(data['document'])
        : <any>undefined;
      if (Array.isArray(data['documentParts'])) {
        this.documentParts = [] as any;
        for (let item of data['documentParts'])
          this.documentParts.push(DocumentParts.fromJS(item));
      }
    }
  }

  static fromJS(data: any): DocumentObservers {
    data = typeof data === 'object' ? data : {};
    let result = new DocumentObservers();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['observationDate'] = this.observationDate
      ? this.observationDate.toISOString()
      : <any>undefined;
    data['documentId'] = this.documentId;
    data['documentVersion'] = this.documentVersion;
    data['document'] = this.document ? this.document.toJSON() : <any>undefined;
    if (Array.isArray(this.documentParts)) {
      data['documentParts'] = [];
      for (let item of this.documentParts)
        data['documentParts'].push(item.toJSON());
    }
    return data;
  }

  clone(): DocumentObservers {
    const json = this.toJSON();
    let result = new DocumentObservers();
    result.init(json);
    return result;
  }
}

export interface IDocumentObservers {
  id: number | undefined;
  observationDate: moment.Moment | undefined;
  documentId: number | undefined;
  documentVersion: number | undefined;
  document: Documents | undefined;
  documentParts: DocumentParts[] | undefined;
}

export class StructureElements implements IStructureElements {
  id: number | undefined;
  name: string | undefined;
  label: string | undefined;
  icon: string | undefined;
  contentTypeId: number | undefined;
  contentType: ContentTypes | undefined;
  regExPatterns: RegExPatterns[] | undefined;
  structureNodes: StructureNodes[] | undefined;

  constructor(data?: IStructureElements) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id'];
      this.name = data['name'];
      this.label = data['label'];
      this.icon = data['icon'];
      this.contentTypeId = data['contentTypeId'];
      this.contentType = data['contentType']
        ? ContentTypes.fromJS(data['contentType'])
        : <any>undefined;
      if (Array.isArray(data['regExPatterns'])) {
        this.regExPatterns = [] as any;
        for (let item of data['regExPatterns'])
          this.regExPatterns.push(RegExPatterns.fromJS(item));
      }
      if (Array.isArray(data['structureNodes'])) {
        this.structureNodes = [] as any;
        for (let item of data['structureNodes'])
          this.structureNodes.push(StructureNodes.fromJS(item));
      }
    }
  }

  static fromJS(data: any): StructureElements {
    data = typeof data === 'object' ? data : {};
    let result = new StructureElements();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['label'] = this.label;
    data['icon'] = this.icon;
    data['contentTypeId'] = this.contentTypeId;
    data['contentType'] = this.contentType
      ? this.contentType.toJSON()
      : <any>undefined;
    if (Array.isArray(this.regExPatterns)) {
      data['regExPatterns'] = [];
      for (let item of this.regExPatterns)
        data['regExPatterns'].push(item.toJSON());
    }
    if (Array.isArray(this.structureNodes)) {
      data['structureNodes'] = [];
      for (let item of this.structureNodes)
        data['structureNodes'].push(item.toJSON());
    }
    return data;
  }

  clone(): StructureElements {
    const json = this.toJSON();
    let result = new StructureElements();
    result.init(json);
    return result;
  }
}

export interface IStructureElements {
  id: number | undefined;
  name: string | undefined;
  label: string | undefined;
  icon: string | undefined;
  contentTypeId: number | undefined;
  contentType: ContentTypes | undefined;
  regExPatterns: RegExPatterns[] | undefined;
  structureNodes: StructureNodes[] | undefined;
}

export class DocumentParts implements IDocumentParts {
  id: number | undefined;
  parentId: number | undefined;
  structureNodeId: number | undefined;
  patternKey: string | undefined;
  patternText: string | undefined;
  documentObserverId: number | undefined;
  documentObserver: DocumentObservers | undefined;
  parent: DocumentParts | undefined;
  structureNode: StructureNodes | undefined;
  inverseParent: DocumentParts[] | undefined;
  partStatusDocumentNewPart: PartStatus[] | undefined;
  partStatusDocumentOldPart: PartStatus[] | undefined;

  constructor(data?: IDocumentParts) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id'];
      this.parentId = data['parentId'];
      this.structureNodeId = data['structureNodeId'];
      this.patternKey = data['patternKey'];
      this.patternText = data['patternText'];
      this.documentObserverId = data['documentObserverId'];
      this.documentObserver = data['documentObserver']
        ? DocumentObservers.fromJS(data['documentObserver'])
        : <any>undefined;
      this.parent = data['parent']
        ? DocumentParts.fromJS(data['parent'])
        : <any>undefined;
      this.structureNode = data['structureNode']
        ? StructureNodes.fromJS(data['structureNode'])
        : <any>undefined;
      if (Array.isArray(data['inverseParent'])) {
        this.inverseParent = [] as any;
        for (let item of data['inverseParent'])
          this.inverseParent.push(DocumentParts.fromJS(item));
      }
      if (Array.isArray(data['partStatusDocumentNewPart'])) {
        this.partStatusDocumentNewPart = [] as any;
        for (let item of data['partStatusDocumentNewPart'])
          this.partStatusDocumentNewPart.push(PartStatus.fromJS(item));
      }
      if (Array.isArray(data['partStatusDocumentOldPart'])) {
        this.partStatusDocumentOldPart = [] as any;
        for (let item of data['partStatusDocumentOldPart'])
          this.partStatusDocumentOldPart.push(PartStatus.fromJS(item));
      }
    }
  }

  static fromJS(data: any): DocumentParts {
    data = typeof data === 'object' ? data : {};
    let result = new DocumentParts();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['parentId'] = this.parentId;
    data['structureNodeId'] = this.structureNodeId;
    data['patternKey'] = this.patternKey;
    data['patternText'] = this.patternText;
    data['documentObserverId'] = this.documentObserverId;
    data['documentObserver'] = this.documentObserver
      ? this.documentObserver.toJSON()
      : <any>undefined;
    data['parent'] = this.parent ? this.parent.toJSON() : <any>undefined;
    data['structureNode'] = this.structureNode
      ? this.structureNode.toJSON()
      : <any>undefined;
    if (Array.isArray(this.inverseParent)) {
      data['inverseParent'] = [];
      for (let item of this.inverseParent)
        data['inverseParent'].push(item.toJSON());
    }
    if (Array.isArray(this.partStatusDocumentNewPart)) {
      data['partStatusDocumentNewPart'] = [];
      for (let item of this.partStatusDocumentNewPart)
        data['partStatusDocumentNewPart'].push(item.toJSON());
    }
    if (Array.isArray(this.partStatusDocumentOldPart)) {
      data['partStatusDocumentOldPart'] = [];
      for (let item of this.partStatusDocumentOldPart)
        data['partStatusDocumentOldPart'].push(item.toJSON());
    }
    return data;
  }

  clone(): DocumentParts {
    const json = this.toJSON();
    let result = new DocumentParts();
    result.init(json);
    return result;
  }
}

export interface IDocumentParts {
  id: number | undefined;
  parentId: number | undefined;
  structureNodeId: number | undefined;
  patternKey: string | undefined;
  patternText: string | undefined;
  documentObserverId: number | undefined;
  documentObserver: DocumentObservers | undefined;
  parent: DocumentParts | undefined;
  structureNode: StructureNodes | undefined;
  inverseParent: DocumentParts[] | undefined;
  partStatusDocumentNewPart: PartStatus[] | undefined;
  partStatusDocumentOldPart: PartStatus[] | undefined;
}

export class StructureConnections implements IStructureConnections {
  id: number | undefined;
  targetStructureNodeId: number | undefined;
  sourceStructureNodeId: number | undefined;
  sourceStructureNode: StructureNodes | undefined;
  targetStructureNode: StructureNodes | undefined;

  constructor(data?: IStructureConnections) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id'];
      this.targetStructureNodeId = data['targetStructureNodeId'];
      this.sourceStructureNodeId = data['sourceStructureNodeId'];
      this.sourceStructureNode = data['sourceStructureNode']
        ? StructureNodes.fromJS(data['sourceStructureNode'])
        : <any>undefined;
      this.targetStructureNode = data['targetStructureNode']
        ? StructureNodes.fromJS(data['targetStructureNode'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): StructureConnections {
    data = typeof data === 'object' ? data : {};
    let result = new StructureConnections();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['targetStructureNodeId'] = this.targetStructureNodeId;
    data['sourceStructureNodeId'] = this.sourceStructureNodeId;
    data['sourceStructureNode'] = this.sourceStructureNode
      ? this.sourceStructureNode.toJSON()
      : <any>undefined;
    data['targetStructureNode'] = this.targetStructureNode
      ? this.targetStructureNode.toJSON()
      : <any>undefined;
    return data;
  }

  clone(): StructureConnections {
    const json = this.toJSON();
    let result = new StructureConnections();
    result.init(json);
    return result;
  }
}

export interface IStructureConnections {
  id: number | undefined;
  targetStructureNodeId: number | undefined;
  sourceStructureNodeId: number | undefined;
  sourceStructureNode: StructureNodes | undefined;
  targetStructureNode: StructureNodes | undefined;
}

export class ContentTypes implements IContentTypes {
  id: number | undefined;
  name: string | undefined;
  structureElements: StructureElements[] | undefined;

  constructor(data?: IContentTypes) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id'];
      this.name = data['name'];
      if (Array.isArray(data['structureElements'])) {
        this.structureElements = [] as any;
        for (let item of data['structureElements'])
          this.structureElements.push(StructureElements.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ContentTypes {
    data = typeof data === 'object' ? data : {};
    let result = new ContentTypes();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    if (Array.isArray(this.structureElements)) {
      data['structureElements'] = [];
      for (let item of this.structureElements)
        data['structureElements'].push(item.toJSON());
    }
    return data;
  }

  clone(): ContentTypes {
    const json = this.toJSON();
    let result = new ContentTypes();
    result.init(json);
    return result;
  }
}

export interface IContentTypes {
  id: number | undefined;
  name: string | undefined;
  structureElements: StructureElements[] | undefined;
}

export class PartStatus implements IPartStatus {
  id: number | undefined;
  documentOldPartId: number | undefined;
  documentNewPartId: number | undefined;
  markedText: string | undefined;
  comparisionStatus: string | undefined;
  documentNewPart: DocumentParts | undefined;
  documentOldPart: DocumentParts | undefined;

  constructor(data?: IPartStatus) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id'];
      this.documentOldPartId = data['documentOldPartId'];
      this.documentNewPartId = data['documentNewPartId'];
      this.markedText = data['markedText'];
      this.comparisionStatus = data['comparisionStatus'];
      this.documentNewPart = data['documentNewPart']
        ? DocumentParts.fromJS(data['documentNewPart'])
        : <any>undefined;
      this.documentOldPart = data['documentOldPart']
        ? DocumentParts.fromJS(data['documentOldPart'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): PartStatus {
    data = typeof data === 'object' ? data : {};
    let result = new PartStatus();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['documentOldPartId'] = this.documentOldPartId;
    data['documentNewPartId'] = this.documentNewPartId;
    data['markedText'] = this.markedText;
    data['comparisionStatus'] = this.comparisionStatus;
    data['documentNewPart'] = this.documentNewPart
      ? this.documentNewPart.toJSON()
      : <any>undefined;
    data['documentOldPart'] = this.documentOldPart
      ? this.documentOldPart.toJSON()
      : <any>undefined;
    return data;
  }

  clone(): PartStatus {
    const json = this.toJSON();
    let result = new PartStatus();
    result.init(json);
    return result;
  }
}

export interface IPartStatus {
  id: number | undefined;
  documentOldPartId: number | undefined;
  documentNewPartId: number | undefined;
  markedText: string | undefined;
  comparisionStatus: string | undefined;
  documentNewPart: DocumentParts | undefined;
  documentOldPart: DocumentParts | undefined;
}

export class StructureElementDto implements IStructureElementDto {
  id: number | undefined;
  name: string | undefined;
  label: string | undefined;
  icon: string | undefined;
  regEx: string | undefined;
  contentTypeId: number | undefined;

  constructor(data?: IStructureElementDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id'];
      this.name = data['name'];
      this.label = data['label'];
      this.icon = data['icon'];
      this.regEx = data['regEx'];
      this.contentTypeId = data['contentTypeId'];
    }
  }

  static fromJS(data: any): StructureElementDto {
    data = typeof data === 'object' ? data : {};
    let result = new StructureElementDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['label'] = this.label;
    data['icon'] = this.icon;
    data['regEx'] = this.regEx;
    data['contentTypeId'] = this.contentTypeId;
    return data;
  }

  clone(): StructureElementDto {
    const json = this.toJSON();
    let result = new StructureElementDto();
    result.init(json);
    return result;
  }
}

export interface IStructureElementDto {
  id: number | undefined;
  name: string | undefined;
  label: string | undefined;
  icon: string | undefined;
  regEx: string | undefined;
  contentTypeId: number | undefined;
}

export class ContentTypeControlDto implements IContentTypeControlDto {
  id: number | undefined;
  name: string | undefined;

  constructor(data?: IContentTypeControlDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id'];
      this.name = data['name'];
    }
  }

  static fromJS(data: any): ContentTypeControlDto {
    data = typeof data === 'object' ? data : {};
    let result = new ContentTypeControlDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    return data;
  }

  clone(): ContentTypeControlDto {
    const json = this.toJSON();
    let result = new ContentTypeControlDto();
    result.init(json);
    return result;
  }
}

export interface IContentTypeControlDto {
  id: number | undefined;
  name: string | undefined;
}

export class StructureDto implements IStructureDto {
  id: number | undefined;
  documentTypeId: number | undefined;
  languageId: number | undefined;
  name: string | undefined;
  nodes: NodeDto[] | undefined;
  connectors: ConnectorDto[] | undefined;

  constructor(data?: IStructureDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id'];
      this.documentTypeId = data['documentTypeId'];
      this.languageId = data['languageId'];
      this.name = data['name'];
      if (Array.isArray(data['nodes'])) {
        this.nodes = [] as any;
        for (let item of data['nodes']) this.nodes.push(NodeDto.fromJS(item));
      }
      if (Array.isArray(data['connectors'])) {
        this.connectors = [] as any;
        for (let item of data['connectors'])
          this.connectors.push(ConnectorDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): StructureDto {
    data = typeof data === 'object' ? data : {};
    let result = new StructureDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['documentTypeId'] = this.documentTypeId;
    data['languageId'] = this.languageId;
    data['name'] = this.name;
    if (Array.isArray(this.nodes)) {
      data['nodes'] = [];
      for (let item of this.nodes) data['nodes'].push(item.toJSON());
    }
    if (Array.isArray(this.connectors)) {
      data['connectors'] = [];
      for (let item of this.connectors) data['connectors'].push(item.toJSON());
    }
    return data;
  }

  clone(): StructureDto {
    const json = this.toJSON();
    let result = new StructureDto();
    result.init(json);
    return result;
  }
}

export interface IStructureDto {
  id: number | undefined;
  documentTypeId: number | undefined;
  languageId: number | undefined;
  name: string | undefined;
  nodes: NodeDto[] | undefined;
  connectors: ConnectorDto[] | undefined;
}

export class NodeDto implements INodeDto {
  id: number | undefined;
  newId: string | undefined;
  contentTypeId: number | undefined;
  offsetX: number | undefined;
  structureElementId: number | undefined;
  offsetY: number | undefined;
  annotations: { [key: string]: string } | undefined;

  constructor(data?: INodeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id'];
      this.newId = data['newId'];
      this.contentTypeId = data['contentTypeId'];
      this.offsetX = data['offsetX'];
      this.structureElementId = data['structureElementId'];
      this.offsetY = data['offsetY'];
      if (data['annotations']) {
        this.annotations = {} as any;
        for (let key in data['annotations']) {
          if (data['annotations'].hasOwnProperty(key))
            this.annotations[key] = data['annotations'][key];
        }
      }
    }
  }

  static fromJS(data: any): NodeDto {
    data = typeof data === 'object' ? data : {};
    let result = new NodeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['newId'] = this.newId;
    data['contentTypeId'] = this.contentTypeId;
    data['offsetX'] = this.offsetX;
    data['structureElementId'] = this.structureElementId;
    data['offsetY'] = this.offsetY;
    if (this.annotations) {
      data['annotations'] = {};
      for (let key in this.annotations) {
        if (this.annotations.hasOwnProperty(key))
          data['annotations'][key] = this.annotations[key];
      }
    }
    return data;
  }

  clone(): NodeDto {
    const json = this.toJSON();
    let result = new NodeDto();
    result.init(json);
    return result;
  }
}

export interface INodeDto {
  id: number | undefined;
  newId: string | undefined;
  contentTypeId: number | undefined;
  offsetX: number | undefined;
  structureElementId: number | undefined;
  offsetY: number | undefined;
  annotations: { [key: string]: string } | undefined;
}

export class ConnectorDto implements IConnectorDto {
  id: number | undefined;
  sourceNodeId: number | undefined;
  newSourceNodeId: string | undefined;
  targetNodeId: number | undefined;
  newTargetNodeId: string | undefined;

  constructor(data?: IConnectorDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id'];
      this.sourceNodeId = data['sourceNodeId'];
      this.newSourceNodeId = data['newSourceNodeId'];
      this.targetNodeId = data['targetNodeId'];
      this.newTargetNodeId = data['newTargetNodeId'];
    }
  }

  static fromJS(data: any): ConnectorDto {
    data = typeof data === 'object' ? data : {};
    let result = new ConnectorDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['sourceNodeId'] = this.sourceNodeId;
    data['newSourceNodeId'] = this.newSourceNodeId;
    data['targetNodeId'] = this.targetNodeId;
    data['newTargetNodeId'] = this.newTargetNodeId;
    return data;
  }

  clone(): ConnectorDto {
    const json = this.toJSON();
    let result = new ConnectorDto();
    result.init(json);
    return result;
  }
}

export interface IConnectorDto {
  id: number | undefined;
  sourceNodeId: number | undefined;
  newSourceNodeId: string | undefined;
  targetNodeId: number | undefined;
  newTargetNodeId: string | undefined;
}

export class ApiException extends Error {
  message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any
  ) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any
): Observable<any> {
  if (result !== null && result !== undefined) return _observableThrow(result);
  else
    return _observableThrow(
      new ApiException(message, status, response, headers, null)
    );
}

function blobToText(blob: any): Observable<string> {
  return new Observable<string>((observer: any) => {
    if (!blob) {
      observer.next('');
      observer.complete();
    } else {
      let reader = new FileReader();
      reader.onload = event => {
        observer.next((<any>event.target).result);
        observer.complete();
      };
      reader.readAsText(blob);
    }
  });
}
